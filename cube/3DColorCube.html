<html>

<head>
  <meta charset="utf-8" />
  <style>
    html,
    body,
    #render-target {
      display: block;
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
    }

    span {
      display: inline-block;
    }

    input[type=number] {
      text-align: right;
      width: 3rem;
    }

    input.color-quantity {
      width: 2rem;
    }

    input.point-color {
      text-align: right;
      width: 2rem;
    }

    input.color {
      width: 2rem;
    }

    #color {
      width: 4rem;
    }

    #color-code {
      width: 4rem;
    }
  </style>
  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
  <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.151.3/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.151.3/examples/jsm/"
        }
      }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Wait for page to load
    window.addEventListener('DOMContentLoaded', () => {
      const renderTargetElement = document.querySelector('#render-target');
      const colorCubeSetting = (() => {
        const me = {
          _sizeElementId: '#sample-size',
          get size() { return parseInt(document.querySelector(this._sizeElementId).value); },

          _intervalElementId: '#sample-interval',
          get interval() { return parseInt(document.querySelector(this._intervalElementId).value); },

          _quantityElementId: '#sample-quantity',
          get quantity() { return parseInt(document.querySelector(this._quantityElementId).value); },

          color: {},

          colorTypes: {
            rgb: {},
            hsv: {},
            hsl: {},
          },
        };

        me.colorTypes.rgb = ((_quantity) => {
          const me = {
            x: { range: {} },
            y: { range: {} },
            z: { range: {} },
            colorCode(_r, _g, _b) {
              return _r * 0x10000 + _g * 0x100 + _b;
            },
          };

          Object.defineProperties(me.x.range, {
            min: _makeIntDiscripter('#sample-color-rgb-r-range-min'),
            max: _makeIntDiscripter('#sample-color-rgb-r-range-max'),
          });
          Object.defineProperties(me.x, {
            quantity: _makeIntDiscripter('#sample-color-rgb-r-quantity'),
          });
          Object.defineProperties(me.y.range, {
            min: _makeIntDiscripter('#sample-color-rgb-g-range-min'),
            max: _makeIntDiscripter('#sample-color-rgb-g-range-max'),
          });
          Object.defineProperties(me.y, {
            quantity: _makeIntDiscripter('#sample-color-rgb-g-quantity'),
          });
          Object.defineProperties(me.z.range, {
            min: _makeIntDiscripter('#sample-color-rgb-b-range-min'),
            max: _makeIntDiscripter('#sample-color-rgb-b-range-max'),
          });
          Object.defineProperties(me.z, {
            quantity: _makeIntDiscripter('#sample-color-rgb-b-quantity'),
          });
          me.x.quantity = _quantity;
          me.y.quantity = _quantity;
          me.z.quantity = _quantity;

          return me;
        })
          (me.quantity);

        me.colorTypes.hsv = ((_quantity) => {
          const me = {
            x: { range: {} },
            y: { range: {} },
            z: { range: {} },
            colorCode(_h, _s, _v) {
              const rgb = {
                r: 0,
                g: 0,
                b: 0,
                get colorCode() {
                  return Math.round(this.r * 255) * 0x10000
                       + Math.round(this.g * 255) * 0x100
                       + Math.round(this.b * 255);
                }
              };

              const saturation = Number(_s) / 100;
              const value = Number(_v) / 100;
              if (saturation == 0) {
                rgb.r = value;
                rgb.g = value;
                rgb.b = value;
              }
              else {
                const hueDivid60 = Number(_h) / 60;
                const hueInt = Math.floor(hueDivid60);
                const hueFraction = hueDivid60 - hueInt;

                const max = value;
                const min = value * (1 - saturation);
                const odd = value * (1 - saturation * hueFraction);
                const even = value * (1 - saturation * (1 - hueFraction));
                switch (hueInt) {
                  case 0:
                  case 6:
                    rgb.r = max;
                    rgb.g = odd;
                    rgb.b = min;
                    break;
                  case 1:
                    rgb.r = even;
                    rgb.g = max;
                    rgb.b = min;
                    break;
                  case 2:
                    rgb.r = min;
                    rgb.g = max;
                    rgb.b = odd;
                    break;
                  case 3:
                    rgb.r = min;
                    rgb.g = even;
                    rgb.b = max;
                    break;
                  case 4:
                    rgb.r = odd;
                    rgb.g = min;
                    rgb.b = max;
                    break;
                  case 5:
                    rgb.r = max;
                    rgb.g = min;
                    rgb.b = even;
                    break;
                }
              }

              return rgb.colorCode;
            },
            colorCode2(_h, _s, _v) {return hsvToRgb16(_h, _s, _v);},
          };

          Object.defineProperties(me.x.range, {
            min: _makeIntDiscripter('#sample-color-hsv-h-range-min'),
            max: _makeIntDiscripter('#sample-color-hsv-h-range-max'),
          });
          Object.defineProperties(me.x, {
            quantity: _makeIntDiscripter('#sample-color-hsv-h-quantity'),
          });
          Object.defineProperties(me.y.range, {
            min: _makeIntDiscripter('#sample-color-hsv-s-range-min'),
            max: _makeIntDiscripter('#sample-color-hsv-s-range-max'),
          });
          Object.defineProperties(me.y, {
            quantity: _makeIntDiscripter('#sample-color-hsv-s-quantity'),
          });
          Object.defineProperties(me.z.range, {
            min: _makeIntDiscripter('#sample-color-hsv-v-range-min'),
            max: _makeIntDiscripter('#sample-color-hsv-v-range-max'),
          });
          Object.defineProperties(me.z, {
            quantity: _makeIntDiscripter('#sample-color-hsv-v-quantity'),
          });
          me.x.quantity = _quantity;
          me.y.quantity = _quantity;
          me.z.quantity = _quantity;

          return me;
        })
          (me.quantity);

        me.colorTypes.hsl = ((_quantity) => {
          const me = {
            x: { range: {} },
            y: { range: {} },
            z: { range: {} },
          };

          Object.defineProperties(me.x.range, {
            min: _makeIntDiscripter('#sample-color-hsl-h-range-min'),
            max: _makeIntDiscripter('#sample-color-hsl-h-range-max'),
          });
          Object.defineProperties(me.x, {
            quantity: _makeIntDiscripter('#sample-color-hsl-h-quantity'),
          });
          Object.defineProperties(me.y.range, {
            min: _makeIntDiscripter('#sample-color-hsl-s-range-min'),
            max: _makeIntDiscripter('#sample-color-hsl-s-range-max'),
          });
          Object.defineProperties(me.y, {
            quantity: _makeIntDiscripter('#sample-color-hsl-s-quantity'),
          });
          Object.defineProperties(me.z.range, {
            min: _makeIntDiscripter('#sample-color-hsl-l-range-min'),
            max: _makeIntDiscripter('#sample-color-hsl-l-range-max'),
          });
          Object.defineProperties(me.z, {
            quantity: _makeIntDiscripter('#sample-color-hsl-l-quantity'),
          });
          me.x.quantity = _quantity;
          me.y.quantity = _quantity;
          me.z.quantity = _quantity;

          return me;
        })
          (me.quantity);

        me.color = me.colorTypes.rgb;
        // me.color = me.colorTypes.hsv;
        // me.color = me.colorTypes.rgb;

        function _makeIntDiscripter(_elementId) {
          return {
            get() {
              return parseInt(document.querySelector(_elementId).value);
            },
            set(_value) {
              if ((typeof _value) !== 'number') _value = parseInt(_value);
              const element = document.querySelector(_elementId);
              if (element.min) {
                const min = parseInt(element.min);
                if (_value < min) _value = min;
              }
              if (element.max) {
                const max = parseInt(element.max);
                if (max < _value) _value = max;
              }
              element.value = _value;
            }
          };
        }

        return me;
      })();
      const renderer = (() => {
        const me = new THREE.WebGLRenderer({
          canvas: renderTargetElement,
          antialias: true
        });
        me.setPixelRatio(window.devicePixelRatio);
        me.setSize(window.innerWidth, window.innerHeight);
        return me;
      })();
      const scene = ((_setting) => {
        const me = new THREE.Scene();
        me.buildColorCube = function (_setting) {
          const group = new THREE.Group();
          const geometry = new THREE.BoxGeometry(_setting.size, _setting.size, _setting.size);
          function makeAxsis(
            _size,
            _interval,
            _axisQuantity,
            _colorRangeMin,
            _colorRangeMax,
          ) {
            const resolution = _axisQuantity - 1;
            const colorResolution = _colorRangeMax - _colorRangeMin;
            return {
              resolution: resolution,
              colorResolution: colorResolution,
              positionOffset: (_interval * resolution + _size) / 2,

              get axis() { return this._axis; },
              set axis(_value) {
                this._axis = _value;
                this.color = (Math.round(colorResolution / resolution * this._axis) + _colorRangeMin);
                this.colorRange = {
                  min: Math.round(colorResolution / resolution * (this._axis - 1)),
                  max: Math.round(colorResolution / resolution * (this._axis + 1)),
                };
                this.position = -((_interval * this._axis) - this.positionOffset);
              },
            }
          };
          const x = makeAxsis(
            _setting.size,
            _setting.interval,
            _setting.color.x.quantity,
            _setting.color.x.range.min,
            _setting.color.x.range.max,
          );
          const y = makeAxsis(
            _setting.size,
            _setting.interval,
            _setting.color.y.quantity,
            _setting.color.y.range.min,
            _setting.color.y.range.max,
          );
          const z = makeAxsis(
            _setting.size,
            _setting.interval,
            _setting.color.z.quantity,
            _setting.color.z.range.min,
            _setting.color.z.range.max,
          );

          for (x.axis = 0; x.axis <= x.resolution; x.axis++) {
            const colorRRange = x.colorRange;
            for (y.axis = 0; y.axis <= y.resolution; y.axis++) {
              const colorGRange = y.colorRange;
              for (z.axis = 0; z.axis <= z.resolution; z.axis++) {
                const colorBRange = z.colorRange;

                const material = new THREE.MeshBasicMaterial({
                  color: _setting.color.colorCode(x.color, y.color, z.color)
                });
                material.colorRange = {
                  r: colorRRange,
                  g: colorGRange,
                  b: colorBRange,
                }
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x.position, y.position, z.position);
                group.add(mesh);
              }
            }
          }
          this.add(group);

          for (let h = 0; h <= 360; h+=60) {
            for (let s = 0; s <= 100; s+=20) {
              for (let v = 0; v <= 100; v+=20) {
                console.log(
                  _setting.color.colorCode(h, s, v).toString(16),
                  // _setting.color.colorCode2(h, s, v).toString(16),
                  h, s, v);
              }
            }
          }
        };

        me.buildColorCube(_setting);

        return me;
      })
        (colorCubeSetting);
      const camera = ((_interval, _quantity, _renderTargetElement) => {
        const distanceBase = _interval * (_quantity + 3);
        const me = new THREE.PerspectiveCamera(45, _renderTargetElement.width / _renderTargetElement.height);
        me.position.set(distanceBase, distanceBase * 0.8, distanceBase * 0.9);

        return me;
      })
      (
        colorCubeSetting.interval,
        colorCubeSetting.quantity,
        renderTargetElement
      );

      const controls = new OrbitControls(camera, renderTargetElement);
      // Smoothly control the camera controller
      controls.enableDamping = true;
      controls.dampingFactor = 0.2;


      // addEventListener
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      renderTargetElement.addEventListener('mousedown', (_mouseEvent) => {
        const material = getMaterial(_mouseEvent);
        if (material) {
          if (material.color) {
            const materialColor = material.color;
            const colorElement = document.querySelector('#color');
            const colorCodeElement = document.querySelector('#color-code');

            colorCodeElement.value = '#'
              + ('00' + (materialColor.r * 0xFF).toString(16)).substr(-2)
              + ('00' + (materialColor.g * 0xFF).toString(16)).substr(-2)
              + ('00' + (materialColor.b * 0xFF).toString(16)).substr(-2);
            colorElement.value = colorCodeElement.value;
            navigator.clipboard.writeText(colorElement.value);
          }
          else {
            console.warn("Woops! Why don't material have color?", material);
          }
        }
      });

      renderTargetElement.addEventListener('dblclick', (_mouseEvent) => {
        const material = getMaterial(_mouseEvent);
        if (material) {
          if (material.colorRange) {
            const materialcolorRange = material.colorRange;
            colorCubeSetting.color.x.range.min = materialcolorRange.r.min;
            colorCubeSetting.color.x.range.max = materialcolorRange.r.max;
            colorCubeSetting.color.y.range.min = materialcolorRange.g.min;
            colorCubeSetting.color.y.range.max = materialcolorRange.g.max;
            colorCubeSetting.color.z.range.min = materialcolorRange.b.min;
            colorCubeSetting.color.z.range.max = materialcolorRange.b.max;
            scene.clear();
            scene.buildColorCube(colorCubeSetting);
          }
          else {
            console.warn("Woops! Why don't material have colorRange?", material);
          }
        }
      });

      renderTargetElement.addEventListener('mousemove', updateCameraPositioin);
      renderTargetElement.addEventListener('wheel', updateCameraPositioin);

      for (const target of [
        '#sample-size',
        '#sample-interval',
        '#sample-color-rgb-r-range-min',
        '#sample-color-rgb-r-range-max',
        '#sample-color-rgb-r-quantity',
        '#sample-color-rgb-g-range-min',
        '#sample-color-rgb-g-range-max',
        '#sample-color-rgb-g-quantity',
        '#sample-color-rgb-b-range-min',
        '#sample-color-rgb-b-range-max',
        '#sample-color-rgb-b-quantity',
      ]) {
        document.querySelector(target).addEventListener('change', (_changeEvent) => {
          scene.clear();
          scene.buildColorCube(colorCubeSetting);
        });
      }

      document.querySelector('#sample-quantity').addEventListener('change', (_changeEvent) => {
        colorCubeSetting.color.x.quantity = _changeEvent.target.value;
        colorCubeSetting.color.y.quantity = _changeEvent.target.value;
        colorCubeSetting.color.z.quantity = _changeEvent.target.value;

        scene.clear();
        scene.buildColorCube(colorCubeSetting);
      });


      // init
      updateCameraPositioin();
      tick();


      // function for eventListener
      function getMaterial(_mouseEvent) {
        const raycaster = new THREE.Raycaster();
        const rect = _mouseEvent.target.getBoundingClientRect();
        const vector = new THREE.Vector2(
          (_mouseEvent.clientX - rect.left) / window.innerWidth * 2 - 1,
          -(_mouseEvent.clientY - rect.top) / window.innerHeight * 2 + 1
        );

        raycaster.setFromCamera(vector, camera);

        const intersects = raycaster.intersectObjects(scene.children);

        if (intersects.length && intersects[0].object.material) {
          return intersects[0].object.material;
        }
        return null;
      }

      function tick() {
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(tick);
      }

      function updateCameraPositioin() {
        const cameraPositionXElement = document.querySelector('#camera-position-x');
        const cameraPositionYElement = document.querySelector('#camera-position-y');
        const cameraPositionZElement = document.querySelector('#camera-position-z');

        cameraPositionXElement.value = Math.floor(camera.position.x);
        cameraPositionYElement.value = Math.floor(camera.position.y);
        cameraPositionZElement.value = Math.floor(camera.position.z);
      }
      function hsvToRgb16(hue, saturation, value) {
        var result = false;

        if (((hue || hue === 0) && hue <= 360) && ((saturation || saturation === 0) && saturation <= 100) && ((value || value === 0) && value <= 100)) {
          var red   = 0,
              green = 0,
              blue  = 0,
              i     = 0,
              f     = 0,
              q     = 0,
              p     = 0,
              t     = 0;

          hue        = Number(hue)        / 60;
          saturation = Number(saturation) / 100;
          value      = Number(value)      / 100;

          if (saturation === 0) {
            red   = value;
            green = value;
            blue  = value;
          } else {
            i = Math.floor(hue);
            f = hue - i;
            p = value * (1 - saturation);
            q = value * (1 - saturation * f);
            t = value * (1 - saturation * (1 - f));

            switch (i) {
              case 0 :
                red   = value;
                green = t;
                blue  = p;
                break;
              case 1 :
                red   = q;
                green = value;
                blue  = p;
                break;
              case 2 :
                red   = p;
                green = value;
                blue  = t;
                break;
              case 3 :
                red   = p;
                green = q;
                blue  = value;
                break;
              case 4 :
                red   = t;
                green = p;
                blue  = value;
                break;
              case 5 :
                red   = value;
                green = p;
                blue  = q;
                break;
            }
          }

          result = {
            red   : Math.round(red   * 255).toString(16),
            green : Math.round(green * 255).toString(16),
            blue  : Math.round(blue  * 255).toString(16)
          };
        }

        return Math.round(red   * 255) * 0x10000
             + Math.round(green * 255) * 0x100
             + Math.round(blue  * 255)
        ;
      };

      function RGBtoHSV (r, g, b, coneModel) {
        var h, // 0..360
            s, v, // 0..255
            max = Math.max(Math.max(r, g), b),
            min = Math.min(Math.min(r, g), b);

        // hue の計算
        if (max == min) {
          h = 0; // 本来は定義されないが、仮に0を代入
        } else if (max == r) {
          h = 60 * (g - b) / (max - min) + 0;
        } else if (max == g) {
          h = (60 * (b - r) / (max - min)) + 120;
        } else {
          h = (60 * (r - g) / (max - min)) + 240;
        }

        while (h < 0) {
          h += 360;
        }

        // saturation の計算
        if (coneModel) {
          // 円錐モデルの場合
          s = max - min;
        } else {
          s = (max == 0)
            ? 0 // 本来は定義されないが、仮に0を代入
            : (max - min) / max * 255;
        }

        // value の計算
        v = max;

        return {'h': h, 's': s, 'v': v};
      }
      function HSVtoRGB (h, s, v) {
        var r, g, b; // 0..255

        while (h < 0) {
          h += 360;
        }

        h = h % 360;

        // 特別な場合 saturation = 0
        if (s == 0) {
          // → RGB は V に等しい
          v = Math.round(v);
          return {'r': v, 'g': v, 'b': v};
        }

        s = s / 255;

        var i = Math.floor(h / 60) % 6,
            f = (h / 60) - i,
            p = v * (1 - s),
            q = v * (1 - f * s),
            t = v * (1 - (1 - f) * s)

        switch (i) {
          case 0 :
            r = v;  g = t;  b = p;  break;
          case 1 :
            r = q;  g = v;  b = p;  break;
          case 2 :
            r = p;  g = v;  b = t;  break;
          case 3 :
            r = p;  g = q;  b = v;  break;
          case 4 :
            r = t;  g = p;  b = v;  break;
          case 5 :
            r = v;  g = p;  b = q;  break;
        }

        return {'r': Math.round(r), 'g': Math.round(g), 'b': Math.round(b)};
      }
    });
  </script>
</head>

<body>
  <div id="display">
    <span comment="setting">
      <span comment="Sample">
        <label>sample</label>
        <div>
          <label>size</label>
          <input id="sample-size" type="number" value="30">
        </div>
        <div>
          <label>interval</label>
          <input id="sample-interval" type="number" value="100">
        </div>
        <div>
          <label>quantity</label>
          <input id="sample-quantity" type="number" min="2" max="16" value="5">
        </div>
      </span>
      <span>
        <label>color type</label>
        <div><input id="sample-coloer-type-rgb" type="radio" name="sampleColoerType" value="rgb" checked>RGB</div>
        <div><input id="sample-coloer-type-hsv" type="radio" name="sampleColoerType" value="hsv">HSV</div>
        <div><input id="sample-coloer-type-hsl" type="radio" name="sampleColoerType" value="hsl">HSL</div>
      </span>
      <span id="color-type-rgb" comment="Color range">
        <span>
          <label>color type RGB</label>
          <div>
            <label>R</label>
            (
            <input id="sample-color-rgb-r-range-min" class="color-rgb" type="number" min="0" max="255" value="0">
            <label>-</label>
            <input id="sample-color-rgb-r-range-max" class="color-rgb" type="number" min="0" max="255" value="255">
            } /
            <input id="sample-color-rgb-r-quantity" class="color-quantity" type="number" min="2" max="16">
            <!-- <input id="sample-color-rgb-r-quantity-range" type="range"  min="2" max="16"> -->
          </div>
          <div>
            <label>G</label>
            (
            <input id="sample-color-rgb-g-range-min" class="color-rgb" type="number" min="0" max="255" value="0">
            <label>-</label>
            <input id="sample-color-rgb-g-range-max" class="color-rgb" type="number" min="0" max="255" value="255">
            } /
            <input id="sample-color-rgb-g-quantity" class="color-quantity" type="number" min="2" max="16">
          </div>
          <div>
            <label>B</label>
            (
            <input id="sample-color-rgb-b-range-min" class="color-rgb" type="number" min="0" max="255" value="0">
            <label>-</label>
            <input id="sample-color-rgb-b-range-max" class="color-rgb" type="number" min="0" max="255" value="255">
            } /
            <input id="sample-color-rgb-b-quantity" class="color-quantity" type="number" min="2" max="16">
          </div>
        </span>
      </span>
      <span id="color-type-hsv" comment="Color range">
        <span>
          <label>color type HSV</label>
          <div>
            <label>H</label>
            (
            <input id="sample-color-hsv-h-range-min" class="color-hsv" type="number" min="0" max="360" value="0">
            <label>-</label>
            <input id="sample-color-hsv-h-range-max" class="color-hsv" type="number" min="0" max="360" value="360">
            ) /
            <input id="sample-color-hsv-h-quantity" class="color-quantity" type="number" min="2" max="16">
          </div>
          <div>
            <label>S</label>
            (
            <input id="sample-color-hsv-s-range-min" class="color-hsv" type="number" min="0" max="100" value="0">
            <label>-</label>
            <input id="sample-color-hsv-s-range-max" class="color-hsv" type="number" min="0" max="100" value="100">
            } /
            <input id="sample-color-hsv-s-quantity" class="color-quantity" type="number" min="2" max="16">
          </div>
          <div>
            <label>V</label>
            (
            <input id="sample-color-hsv-v-range-min" class="color-hsv" type="number" min="0" max="100" value="0">
            <label>-</label>
            <input id="sample-color-hsv-v-range-max" class="color-hsv" type="number" min="0" max="100" value="100">
            } /
            <input id="sample-color-hsv-v-quantity" class="color-quantity" type="number" min="2" max="16">
          </div>
        </span>
      </span>
      <span id="color-type-hsl" comment="Color range">
        <span>
          <label>color type HSL</label>
          <div>
            <label>H</label>
            (
            <input id="sample-color-hsl-h-range-min" class="color-hsl" type="number" min="0" max="360" value="0">
            <label>-</label>
            <input id="sample-color-hsl-h-range-max" class="color-hsl" type="number" min="0" max="360" value="360">
            } /
            <input id="sample-color-hsl-h-quantity" class="color-quantity" type="number" min="2" max="16">
          </div>
          <div>
            <label>S</label>
            (
            <input id="sample-color-hsl-s-range-min" class="color-hsl" type="number" min="0" max="100" value="0">
            <label>-</label>
            <input id="sample-color-hsl-s-range-max" class="color-hsl" type="number" min="0" max="100" value="100">
            } /
            <input id="sample-color-hsl-s-quantity" class="color-quantity" type="number" min="2" max="16">
          </div>
          <div>
            <label>L</label>
            (
            <input id="sample-color-hsl-l-range-min" class="color-hsl" type="number" min="0" max="100" value="0">
            <label>-</label>
            <input id="sample-color-hsl-l-range-max" class="color-hsl" type="number" min="0" max="100" value="100">
            } /
            <input id="sample-color-hsl-l-quantity" class="color-quantity" type="number" min="2" max="16">
          </div>
        </span>
      </span>
    </span>
    <span comment="Color">
      <span>
        <div>
          <label>Color</label>
        </div>
        <div>
          <input id="color" type="color" disabled>
        </div>
        <div>
          <input id="color-code" type="text" disabled>
        </div>
      </span>
      <span>
        <div>
          <label>RGB</label>
        </div>
        <div>
          <label>R</label>
          <input id="point-color-rgb-r" class="point-color" type="text" disabled>
        </div>
        <div>
          <label>G</label>
          <input id="point-color-rgb-g" class="point-color" type="text" disabled>
        </div>
        <div>
          <label>B</label>
          <input id="point-color-rgb-b" class="point-color" type="text" disabled>
        </div>
      </span>
      <span>
        <div>
          <label>HSV</label>
        </div>
        <div>
          <label>H</label>
          <input id="point-color-hsv-h" class="point-color" type="text" disabled>
        </div>
        <div>
          <label>S</label>
          <input id="point-color-hsv-s" class="point-color" type="text" disabled>
        </div>
        <div>
          <label>V</label>
          <input id="point-color-hsv-v" class="point-color" type="text" disabled>
        </div>
      </span>
      <span>
        <div>
          <label>HSV</label>
        </div>
        <div>
          <label>H</label>
          <input id="point-color-hsv-h" class="point-color" type="text" disabled>
        </div>
        <div>
          <label>S</label>
          <input id="point-color-hsv-s" class="point-color" type="text" disabled>
        </div>
        <div>
          <label>V</label>
          <input id="point-color-hsv-v" class="point-color" type="text" disabled>
        </div>
      </span>
    </span>
    <span comment="CameraPosition">
      <div>
        <label>CameraPosition</label>
      </div>
      <div>
        <label>X</label>
        <input id="camera-position-x" type="number">
      </div>
      <div>
        <label>Y</label>
        <input id="camera-position-y" type="number">
      </div>
      <div>
        <label>Z</label>
        <input id="camera-position-z" type="number">
      </div>
    </span>
  </div>
  <canvas id="render-target" width="2400" height="2400"></canvas>
</body>

</html>